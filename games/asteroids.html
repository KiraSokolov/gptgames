<!DOCTYPE html>
<html>
<head>
  <title>Asteroids Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
      body {
          margin: 0;
          padding: 0;
      }

      canvas {
          display: block;
          margin: 0 auto;
          border: 1px solid black;
          background: black;
      }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script type="text/javascript">
  // Game variables
  var canvas;
  var canvasContext;
  var playerShip;
  var gameStarted = false;
  var gamePaused = false;
  var gameEnded = false;
  var gameScore = 0;
  var gameLives = 3;
  var asteroids = [];
  var enemies = [];
  var bullets = [];
  var maxEnemies = 15;
  var enemySpawnRate = 5000;
  var lastEnemySpawnTime = 0;

  // Player ship variables
  var shipRadius = 20;
  var shipAcceleration = 0.2;
  var shipMaxSpeed = 5;
  var shipFriction = 0.98;
  var shipShotTimer = 0;
  var shipShotDelay = 50;
  var shipShotSpeed = 6;

  // Asteroid variables
  var asteroidSpeed = 2;
  var asteroidSize = [60, 40, 20];

  // Enemy variables
  var enemySpeed = 3;
  var enemySize = 30;
  var enemyShotDelay = 3000;
  var enemyShotSpeed = 4;

  // Keyboard variables
  var keyLeft = false;
  var keyRight = false;
  var keyUp = false;
  var keyDown = false;
  var keySpace = false;

  // Initialize the game
  function init() {
    canvas = document.getElementById('gameCanvas');
    canvasContext = canvas.getContext('2d');
    gameStarted = true;

    playerShip = new Ship(canvas.width / 2, canvas.height / 2, 0);
    playerShip.color = 'white';

    // Create asteroids
    for (var i = 0; i < 5; i++) {
      var randX = Math.floor(Math.random() * canvas.width);
      var randY = Math.floor(Math.random() * canvas.height);
      var randSpeed = Math.random() * 0.5 + 0.5;
      asteroids.push(new Asteroid(randX, randY, asteroidSize[0], randSpeed));
    }

    // Start the game loop
    requestAnimationFrame(gameLoop);
  }

  // Game loop
  function gameLoop() {
    if (!gameEnded) {
      // Update the game
      update();

      // Draw the game
      draw();

      // Continue the game loop
      requestAnimationFrame(gameLoop);
    }
  }

  // Update the game
  function update() {
    if (gameStarted && !gamePaused) {
      // Update player ship
      playerShip.update();

      // Update asteroids
      for (var i = 0; i < asteroids.length; i++) {
        asteroids[i].update();
      }

      // Update enemies
      for (var i = 0; i < enemies.length; i++) {
        enemies[i].update();
      }

      // Update bullets
      for (var i = 0; i < bullets.length; i++) {
        bullets[i].update();
      }

      // Spawn enemies
      var currentTime = new Date().getTime();
      if (enemies.length < maxEnemies && currentTime - lastEnemySpawnTime > enemySpawnRate) {
        lastEnemySpawnTime = currentTime;
        var randX = Math.floor(Math.random() * canvas.width);
        var randY = Math.floor(Math.random() * canvas.height);
        enemies.push(new Enemy(randX, randY));
      }
    }
  }

  // Draw the game
  function draw() {
    canvasContext.clearRect(0, 0, canvas.width, canvas.height);

// Draw player ship
    playerShip.draw();

// Draw asteroids
    for (var i = 0; i < asteroids.length; i++) {
      asteroids[i].draw();
    }

// Draw enemies
    for (var i = 0; i < enemies.length; i++) {
      enemies[i].draw();
    }

// Draw bullets
    for (var i = 0; i < bullets.length; i++) {
      bullets[i].draw();
    }

// Draw score
    canvasContext.fillStyle = 'white';
    canvasContext.font = '24px Arial';
    canvasContext.fillText('Score: ' + gameScore, 20, 30);

// Draw lives
    canvasContext.fillText('Lives: ' + gameLives, canvas.width - 100, 30);

// Draw game over screen
    if (gameEnded) {
      canvasContext.fillStyle = 'white';
      canvasContext.font = '36px Arial';
      canvasContext.textAlign = 'center';
      canvasContext.fillText('Game Over', canvas.width / 2, canvas.height / 2);
      canvasContext.font = '24px Arial';
      canvasContext.fillText('Final Score: ' + gameScore, canvas.width / 2, canvas.height / 2 + 40);
      canvasContext.fillText('Press R to restart', canvas.width / 2, canvas.height / 2 + 80);
    }
  }

  // Restart the game
  function restart() {
    gameStarted = false;
    gamePaused = false;
    gameEnded = false;
    gameScore = 0;
    gameLives = 3;
    asteroids = [];
    enemies = [];

// Create asteroids
    for (var i = 0; i < 5; i++) {
      var randX = Math.floor(Math.random() * canvas.width);
      var randY = Math.floor(Math.random() * canvas.height);
      asteroids.push(new Asteroid(randX, randY, asteroidSize[0], 0));
    }

// Start the game loop
    requestAnimationFrame(gameLoop);
  }

  // Player ship object
  function Ship(x, y, angle) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.speedX = 0;
    this.speedY = 0;
    this.color = 'white';

    this.draw = function () {
      canvasContext.save();
      canvasContext.translate(this.x, this.y);
      canvasContext.rotate(this.angle);
      canvasContext.beginPath();
      canvasContext.moveTo(0, -shipRadius);
      canvasContext.lineTo(shipRadius, shipRadius);
      canvasContext.lineTo(0, shipRadius / 2);
      canvasContext.lineTo(-shipRadius, shipRadius);
      canvasContext.closePath();
      canvasContext.strokeStyle = this.color;
      canvasContext.stroke();
      canvasContext.restore();
    };

    this.update = function () {
      // Move the ship
      this.x += this.speedX;
      this.y += this.speedY;

      // Wrap around the screen
      if (this.x < -shipRadius) {
        this.x = canvas.width + shipRadius;
      } else if (this.x > canvas.width + shipRadius) {
        this.x = -shipRadius;
      }
      if (this.y < -shipRadius) {
        this.y = canvas.height + shipRadius;
      } else if (this.y > canvas.height + shipRadius) {
        this.y = -shipRadius;
      }

      // Rotate the ship
      if (keyLeft) {
        this.angle -= 0.1;
      } else if (keyRight) {
        this.angle += 0.1;
      }

// Calculate the velocity vector based on the ship's angle
      var velX = Math.cos(this.angle - Math.PI / 2);
      var velY = Math.sin(this.angle - Math.PI / 2);

// Accelerate the ship
      if (keyUp) {
        this.speedX += velX * shipAcceleration;
        this.speedY += velY * shipAcceleration;
        // Limit the speed
        this.speedX = Math.min(Math.max(this.speedX, -shipMaxSpeed), shipMaxSpeed);
        this.speedY = Math.min(Math.max(this.speedY, -shipMaxSpeed), shipMaxSpeed);
      }

      // Decelerate the ship
      this.speedX *= shipFriction;
      this.speedY *= shipFriction;

      // Shoot a bullet
      if (keySpace && shipShotTimer <= 0) {
        var bulletX = this.x + velX * shipRadius;
        var bulletY = this.y + velY * shipRadius;
        var bulletSpeedX = this.speedX + velX * shipShotSpeed;
        var bulletSpeedY = this.speedY + velY * shipShotSpeed;
        var bullet = new Bullet(bulletX, bulletY, bulletSpeedX, bulletSpeedY);
        bullets.push(bullet);
        shipShotTimer = shipShotDelay;
      } else {
        shipShotTimer--;
      }
    };
  }

  // Asteroid object
  function Asteroid(x, y, size, speed) {
    this.x = x;
    this.y = y;
    this.size = size;
    this.speed = speed;
    this.angle = Math.random() * Math.PI * 2;
    this.vertices = Math.floor(Math.random() * 5 + 5);
    this.offsets = [];
    for (var i = 0; i < this.vertices; i++) {
      var randOffset = (Math.random() - 0.5) * this.size / 2;
      this.offsets.push(randOffset);
    }

    this.draw = function () {
      canvasContext.beginPath();
      canvasContext.moveTo(
        this.x + this.size * Math.cos(this.angle + this.offsets[0]),
        this.y + this.size * Math.sin(this.angle + this.offsets[0])
      );
      for (var i = 1; i < this.vertices; i++) {
        canvasContext.lineTo(
          this.x + this.size * Math.cos(this.angle + this.offsets[i]),
          this.y + this.size * Math.sin(this.angle + this.offsets[i])
        );
      }
      canvasContext.closePath();
      canvasContext.strokeStyle = 'white';
      canvasContext.stroke();
    };

    this.update = function () {
      // Move the asteroid
      this.x += this.speed * Math.cos(this.angle);
      this.y += this.speed * Math.sin(this.angle);

      // Wrap around the screen
      if (this.x < -this.size) {
        this.x = canvas.width + this.size;
      } else if (this.x > canvas.width + this.size) {
        this.x = -this.size;
      }
      if (this.y < -this.size) {
        this.y = canvas.height + this.size;
      } else if (this.y > canvas.height + this.size) {
        this.y = -this.size;
      }
    };
  }

  // Enemy object
  function Enemy(x, y) {
    this.x = x;
    this.y = y;
    this.color = 'red';
    this.speedX = 0;
    this.speedY = 0;
    this.angle = Math.random() * Math.PI * 2;
    this.radius = enemySize;
    this.shotTimer = 0;

    this.draw = function () {
      canvasContext.beginPath();
      canvasContext.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      canvasContext.strokeStyle = this.color;
      canvasContext.stroke();
    };

    this.update = function () {
      // Move the enemy
      this.x += this.speedX;
      this.y += this.speedY;

      // Wrap around the screen
      if (this.x < -this.radius) {
        this.x = canvas.width + this.radius;
      } else if (this.x > canvas.width + this.radius) {
        this.x = -this.radius;
      }
      if (this.y < -this.radius) {
        this.y = canvas.height + this.radius;
      } else if (this.y > canvas.height + this.radius) {
        this.y = -this.radius;
      }

      // Shoot a bullet
      if (this.shotTimer <= 0) {
        var bulletX = this.x + Math.cos(this.angle) * this.radius;
        var bulletY = this.y + Math.sin(this.angle) * this.radius;
        var bulletSpeedX = Math.cos(this.angle) * enemyShotSpeed;
        var bulletSpeedY = Math.sin(this.angle) * enemyShotSpeed;
        var bullet = new Bullet(bulletX, bulletY, bulletSpeedX, bulletSpeedY);
        bullets.push(bullet);
        this.shotTimer = enemyShotDelay;
      } else {
        this.shotTimer--;
      }
    };
  }

  // Bullet object
  function Bullet(x, y, speedX, speedY) {
    this.x = x;
    this.y = y;
    this.speedX = speedX;
    this.speedY = speedY;
    this.radius = 3;

    this.draw = function () {
      canvasContext.beginPath();
      console.log(this.x, this.y, this.radius);
      canvasContext.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      canvasContext.fillStyle = 'white';
      canvasContext.fill();
    };

    this.update = function () {
      this.x += this.speedX;
      this.y += this.speedY;
    };
  }

  // Keyboard event listeners
  document.addEventListener('keydown', function (event) {
    if (event.keyCode == 37) { // Left arrow
      keyLeft = true;
    } else if (event.keyCode == 39) { // Right arrow
      keyRight = true;
    } else if (event.keyCode == 38) { // Up arrow
      keyUp = true;
    } else if (event.keyCode == 40) { // Down arrow
      keyDown = true;
    } else if (event.keyCode == 32) { // Space
      keySpace = true;
    } else if (event.keyCode == 82 && gameEnded) { // R
      restart();
    }
  });

  document.addEventListener('keyup', function (event) {
    if (event.keyCode == 37) { // Left arrow
      keyLeft = false;
    } else if (event.keyCode == 39) { // Right arrow
      keyRight = false;
    } else if (event.keyCode == 38) { // Up arrow
      keyUp = false;
    } else if (event.keyCode == 40) { // Down arrow
      keyDown = false;
    } else if (event.keyCode == 32) { // Space
      keySpace = false;
    }
  });

  // Start the game
  init();
</script>
</body>
</html>